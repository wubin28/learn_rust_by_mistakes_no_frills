[目录](../README_zh.md)
# 第1章 避开C++式内存安全陷阱

# 1.1 为避开C++内存安全问题而生

2003年1月25日，安全专家阿里耶·戈雷茨基接到紧急来电——公司服务器房内一片混乱。原因是SQL Slammer蠕虫正在利用C++编写的Microsoft SQL Server中的缓冲区溢出漏洞肆虐。这次事件导致全球数千网络瘫痪，互联网遭受重创。

此事在往前15年，1988年，同样由C语言编写的Unix系统漏洞也曾被莫里斯蠕虫利用，瘫痪了约10%的互联网系统。C和C++虽然性能卓越，但将内存安全视为可选项。这意味着主要依靠程序员自觉遵守良好实践和第三方工具的检查，而语言本身并不内置内存安全保护机制，从而埋下安全隐患。

2006年，C++程序员格雷登·霍尔因公寓电梯嵌入式软件崩溃被迫爬21楼回家。沮丧之际，他决心开发一种将内存安全作为必选项的新编程语言——Rust。

2009年，Rust项目启动。次年，Mozilla公司组建Rust团队，开始孵化这一全新语言。2015年，Rust 1.0版本正式对外发布。

程序员们对Rust爱不释手。自2016年起，Rust连续9年在Stack Overflow的"最受喜爱的编程语言"榜单上荣登榜首。

除苹果外，美国科技四巨头纷纷拥抱Rust。Facebook率先于2016年将其用于开发大型源代码管理系统。微软、亚马逊、谷歌也陆续将Rust应用到Azure IoT Edge、AWS Lambda、Fuchsia等关键项目中。谷歌在Android开发中引入Rust后，内存安全漏洞比例从76%骤降至24%。

就连Linux之父林纳斯·托瓦兹也承认，Rust有望成为继C和汇编之后的第三种Linux内核官方开发语言。2023年，首个Rust驱动在Linux 6.8内核中发布。

美国政府呼吁废弃C/C++，转向Rust等内存安全语言。在此压力下，C++之父比雅尼·斯特劳斯特鲁普承认，单靠外部工具无法保证C++的内存安全，必须在语言自身下功夫。2024年9月，C++联盟提出"安全C++扩展提案"，借鉴Rust引入严格内存安全特性。

由此可见，Rust不仅修复了长期困扰C/C++的内存安全问题，还撼动了C/C++统治系统级和高性能编程半个多世纪的霸主地位，引领软件工程迈入崭新的安全时代。

# 1.2 C++智能指针的悬垂隐患

C++，作为C语言的扩展，于1985年由丹麦计算机科学家比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）首次发布，旨在引入面向对象编程特性。这门强大而灵活的编程语言在众多领域广受青睐，尤其是在高性能要求的场景中大显身手，如系统软件、游戏开发、嵌入式系统、实时计算和高性能计算等。C++凭借其高效的内存管理能力、对底层编程的支持以及直接访问硬件的特性，在需要精细控制硬件和资源的应用中备受欢迎。

2023年JetBrains全球开发者生态调查显示，[25%的受访程序员在过去一年中使用过C++](https://www.jetbrains.com/lp/devecosystem-2023/languages/)，仅次于JavaScript、Python和Java。截至本书撰写时，JetBrains的统计数据表明，[C++17是程序员最常用的C++版本](https://www.jetbrains.com/lp/devecosystem-2023/cpp/)。

不幸的是，C++这门广泛应用的编程语言长期受到悬垂指针（dangling pointer）问题的困扰。悬垂指针是C/C++等需要手动管理内存的语言中常见的隐患，可能引发数据不可预测、内存安全漏洞和程序崩溃等严重后果。

悬垂指针是指在程序运行过程中出现以下任一情况的指针：

- 指向已释放的内存：指针所指向的内存已被释放（如通过delete操作），但指针本身的值未被修改，仍指向那块已释放的内存区域。
- 指向已重新分配的内存：指针所指向的内存已被分配给其他数据（如在堆上重新分配），但指针的值未更新，仍指向旧的内存地址。
- 指向局部变量的数据：指针指向局部变量所持有的数据，但在该局部变量超出作用域变得无效后仍被使用。此时，指针指向的是已失效的栈内存。

简而言之，悬垂指针是一种"徒有其表"的指针，其指向的内存要么已失效，要么已被重新分配给其他数据。再次解引用（dereference）这样的指针会导致未定义行为。这是C/C++编程中的一个常见陷阱，如下代码所示：

```cpp
int* createInt() {
    // local是局部变量，其内存在函数返回后就无效了
    int local = 55;
    return &local; // 返回局部变量的地址
}

// p仍然指向这块无效的内存，成为了悬垂指针
int* p = createInt(); 

```

C++处理悬垂指针的方法经历了逐步完善。早期（C++98之前）完全依赖手动内存管理，容易引发问题。C++98/03引入`auto_ptr`作为智能指针，简化了内存管理但存在缺陷。C++11引入`unique_ptr`、`shared_ptr`和`weak_ptr`等智能指针，显著缓解了悬垂指针问题。C++14/17/20进一步推广智能指针使用，并引入新特性以减少手动内存管理需求。

C++11中的智能指针大大改善了动态内存管理，但并未彻底解决悬垂指针问题。程序员仍需谨慎管理指针，遵循良好的编程实践（如RAII）来避免悬垂指针。

然而，即便使用智能指针，C++仍存在一些潜在陷阱。

## 1.2.1 踩坑过程

你能猜出代码清单1-1中隐藏的危险吗？不妨运行一下代码来验证你的猜测。运行C++代码最简单的方法是将代码复制粘贴到网页[www.mycompiler.io/new/cpp](https://www.mycompiler.io/new/cpp)的左侧编辑区，然后点击右上角的Run按钮。随后，你就能在右侧看到运行结果了。

代码清单1-1 ch01/cpp_dangling_ptr_zh

```cpp
// 包含输入输出流库，用于使用std::cout进行控制台输出
#include <iostream>
// 包含内存管理库，提供智能指针如std::shared_ptr的支持
#include <memory>

int main()
{
  // 创建一个裸指针，初始化为nullptr，表示不指向任何有效的内存地址
  int* rawPtr = nullptr;

  {  // 开始一个新的作用域，用于限定smartPtr的生存期
    // 创建智能指针smartPtr，指向一个值为55的int对象，
    // std::指的是shared_ptr是C++标准库中提供的智能指针
    std::shared_ptr<int> smartPtr = std::make_shared<int>(55);
    rawPtr = smartPtr.get();  // 获取智能指针所管理的裸指针

    std::cout << "智能指针管理的值: " << *smartPtr << std::endl;
    std::cout << "裸指针指向的值: " << *rawPtr << std::endl;
  }  // smartPtr 在此作用域结束后被销毁，管理的内存被释放

  // 此时rawPtr成为悬垂指针
  // 未定义行为，在不同环境运行可能看到不同的值，也可能崩溃
  std::cout << "尝试访问悬垂裸指针的值: " << *rawPtr
            << std::endl;  

  return 0;
}
// 运行输出:
// 智能指针管理的值: 55
// 裸指针指向的值: 55
// 尝试访问悬垂裸指针的值: 0
```

## 1.2.2 为何踩坑

代码清单1-1展示了从C++智能指针获取裸指针的过程及其潜在问题。这段代码主要完成以下步骤：

1. 使用智能指针创建并管理一个整数。
2. 从该智能指针获取一个裸指针。
3. 智能指针被销毁后，裸指针变成悬垂指针，仍指向已释放的内存。
4. 代码尝试使用这个悬垂指针，展示了这种操作的危险性。

代码清单1-1中的隐患源于C++允许智能指针和裸指针之间的双向转换。虽然这种灵活性带来便利，但不当使用极易引发悬垂指针问题。

运行结果表明，访问悬垂指针可能产生意外值。在本地计算机上可能得到0，而在mycompiler.io网页上可能得到55。这种不可预测性可能导致程序崩溃或安全漏洞。

这个例子清晰地展示了从C++智能指针获取裸指针的潜在风险。智能指针销毁后，相关的裸指针可能变成悬垂指针。因此，使用智能指针时必须谨慎处理裸指针，以避免产生悬垂指针。

# 1.3 用Rust引用避开智能指针的悬垂陷阱

Rust如何巧妙地避免智能指针衍生的引用变成悬垂引用，从而规避C++中常见的这一陷阱？

## 1.3.1 如何避开C++式的悬垂陷阱

让我们一起探索代码清单1-2，看看Rust是如何巧妙解决这个棘手问题的。

代码清单1-2 ch01/avoid_dangling_ptrs_with_refs/pitfalls_zh

```rust
 1 fn main() {
 2     // 声明名为reference的变量，但暂不初始化
 3     let reference;
 4 
 5     { // 开始一个新作用域
 6         // 绑定类型为Box<i32>的智能指针smart_ptr，存储整数值55，Box在堆上分配内存
 7         let smart_ptr = Box::new(55);
 8         // 变量reference的类型在这里进行初始化时才会被推断出来
 9         // 下面解释表达式&*smart_ptr：
10         // 首先*解引用操作符将Box智能指针解引用到其在堆上管理的i32值
11         // 然后&引用创建操作符创建了这个堆上值的引用
12         // 最后将这个引用初始化给变量reference
13         reference = &*smart_ptr;
14 
15         println!("智能指针管理的值: {}", smart_ptr);
16 
17         println!("引用指向的值: {}", reference);
18     } // smart_ptr在此作用域结束后被销毁
19 
20     // 尝试使用悬垂引用reference会导致编译错误
21     println!("引用指向的值: {}", reference);
22 }
23 // 编译错误:
24 // error[E0597]: `*smart_ptr` does not live long enough
```

与代码清单1-1中的C++代码不同，Rust的编译器会阻止代码清单1-2中含有悬垂引用的代码运行。C++代码存在悬垂指针却仍能编译通过并"带病运行"，从而产生未定义行为。而Rust在编译阶段就能发现这类问题（为节省篇幅，代码清单1-2只展示了编译错误信息的第一行）。

如果你对此持怀疑态度，不妨按照接下来的方法亲自编译和运行一下代码，亲眼见证Rust的安全保障。

<aside>
💡

如何运行代码清单1-2中的Rust代码？

最简单的方法是将不含行号的代码复制粘贴到网页[www.mycompiler.io/new/rust](https://www.mycompiler.io/new/rust)的左侧编辑区。点击右上角的Run按钮后，即可在右侧查看运行结果。

若想在本地计算机上运行，请按以下步骤操作（为节省篇幅，仅提供要点。详细说明可咨询你喜爱的AI聊天工具）：

1. 安装Rust环境：使用rustup进行安装。
2. 验证Rust环境安装：运行命令`rustc --version`。
3. 创建Rust项目：运行命令`cargo new hello_world_rust`（将`hello_world_rust`替换为你的项目名）。
4. 格式化代码：运行命令`cargo fmt`。
5. 检查语法：运行命令`cargo check`。
6. 编译：运行命令`cargo build`，将在target/debug文件夹中生成编译结果。
7. 运行：执行命令`cargo run`。
8. 运行代码清单1-2：用不含行号的代码清单1-2替换`./src/main.rs`文件中的原有代码，然后重复上述格式化、检查、编译和运行步骤。
</aside>

Rust编译器拥有一个强大的工具——借用检查器。它在编译过程中就开始工作，主要负责：

- 追踪每个变量和引用的生存期
- 确保引用不会比其指向的值存活更长时间
- 检查所有变量和引用的使用范围
- 保证所有引用在使用时都是有效的

简而言之，借用检查器的任务是在程序运行前预防悬垂引用问题。

一旦借用检查器检测到潜在的悬垂引用，它会立即触发编译错误。这意味着程序无法编译通过，直到问题被修复。这种机制显著提升了程序的安全性。

在代码清单1-2中，`reference`变量试图持有`smart_ptr`解引用值的引用（即`&*smart_ptr`）。然而，`smart_ptr`在其作用域结束时会被销毁。Rust编译器敏锐地发现`reference`的生存期超出了`smart_ptr`的生存期，这会导致引用失效。因此，编译器果断报错并阻止代码运行，从根本上杜绝了悬垂引用带来的内存安全隐患。

## 1.3.2 如何修复Rust的编译错误

既然代码清单1-2中的悬垂引用陷阱源自`reference`比`smart_ptr`存活更长，我们该如何避开这个陷阱呢？

最简单直接的方法是确保`reference`不会比`smart_ptr`存活更长。有两种实现方式：一是删除第5行和第18行的作用域大括号，扩大`smart_ptr`的生存期；二是将第7行`smart_ptr`的绑定拆分为声明和初始化两步，并将声明移至第5行作用域大括号之前。这样，虽然`reference`和`smart_ptr`的生存期起点不同，但它们会同时结束，从而有效避免悬垂引用，如代码清单1-3所示：

代码清单1-3 ch01/avoid_dangling_ptrs_with_refs/mitigation_zh

```rust
fn main() {
    let reference;
    let smart_ptr;

    {
        smart_ptr = Box::new(55);
        reference = &*smart_ptr;

        println!("智能指针管理的值: {}", smart_ptr);
        println!("引用指向的值: {}", reference);
    }

    println!("引用指向的值: {}", reference);
}
// 运行输出:
// 智能指针管理的值: 55
// 引用指向的值: 55
// 引用指向的值: 55
```

# 1.4 Rust智能指针的悬垂陷阱

Rust的借用检查器虽然能有效防止大多数悬垂引用问题，但在某些特殊情况下——尤其是涉及裸指针使用时——仍需格外谨慎。

## 1.4.1 踩坑过程

在Rust中，不当使用裸指针也可能导致类似C++的智能指针悬垂陷阱。这是真的吗？那就多运行几次代码清单1-4，观察最后一行运行输出的结果。

代码清单1-4 ch01/dangling_ptr_from_smart_ptr/pitfalls_zh

```rust
 1 fn main() {
 2     // 声明一个变量，但暂不初始化
 3     let raw_ptr;
 4
 5     { // 开始一个新作用域
 6         let smart_ptr = Box::new(55);
 7         // 从智能指针获取裸指针
 8         raw_ptr = &*smart_ptr as *const i32;
 9
10         println!("智能指针管理的值: {}", smart_ptr);
11         unsafe {
12             println!("裸指针指向的值: {}", *raw_ptr);
13         }
14     } // smart_ptr在此作用域结束后被销毁，其指向的内存被释放
15
16     // 尝试使用悬垂指针raw_ptr
17     unsafe {
18         // 编译通过，运行时产生未定义行为
19         println!("尝试访问悬垂裸指针指向的值（每次运行都不一样）: {}", *raw_ptr);
20     }
21 }
22 // 运行输出:
23 // 智能指针管理的值: 55
24 // 裸指针指向的值: 55
25 // 尝试访问悬垂裸指针指向的值（每次运行都不一样）: -693338112
```

## 1.4.2 为何踩坑

每次运行代码清单1-4中的代码，最后一行运行输出的悬垂裸指针指向的值都会不同。为什么会出现这种情况呢？

第6行中，智能指针`smart_ptr`被定义在一个局部作用域 `{ ... }` 内，并通过`Box::new(55)`在堆上分配了一个整数。接着在第8行，代码使用 `&*smart_ptr as *const i32` 将`smart_ptr`智能指针管理的堆上值的引用转换为裸指针，并将其初始化给变量`raw_ptr`。

`*const i32` 表示一个指向 `i32` 的常量（不可变）裸指针。`as` 关键字用于执行显式类型转换。在 `*const i32` 中，`*` 表示这是一个指针类型，`const` 表示指针指向的数据是常量（不可通过此指针修改），而 `i32` 是指针指向的数据类型。这种转换将安全的 Rust 引用转换为不受借用规则限制的不安全裸指针。虽然裸指针提供了更大的灵活性，但使用时需要格外小心，因为它绕过了 Rust 的内存安全保障。

当局部作用域结束时，`smart_ptr`被销毁，其指向的内存随即释放。尽管`raw_ptr`仍然存在，它所指向的内存已经失效，变成了悬垂指针。这个裸指针不再指向有效数据，继续使用它将导致未定义行为。难怪每次运行程序都会得到一个不同的值。

虽然在Rust中我们也遇到了悬垂指针的问题，但这个问题只出现在`unsafe`代码块中。Rust强制要求在使用裸指针时必须加上`unsafe`关键字。与C++在使用裸指针时不做任何特殊标记不同，Rust通过`unsafe`块明确提醒程序员：在这里，你需要自己承担起确保内存安全的责任。

## 1.4.3 如何避坑

该如何解决代码清单1-4中的Rust智能指针的悬垂陷阱？你能用1.3.2所学到的避坑技巧来解决吗？

解决方案至少有两个。第一个方案与1.3.2讨论的解决方案相似：可以删除第5和第14行的大括号，或者将`smart_ptr`的声明与初始化分开，并将声明移到第5行大括号之前。这样做的目的是让`raw_ptr`不会比`smart_ptr`活得更久，如代码清单1-5所示：

代码清单1-5 ch01/dangling_ptr_from_smart_ptr/mitigation_zh

```rust
fn main() {
    let raw_ptr;
    let smart_ptr;

    {
        smart_ptr = Box::new(55);
        raw_ptr = &*smart_ptr as *const i32;

        println!("智能指针管理的值: {}", smart_ptr);
        unsafe {
            println!("裸指针指向的值: {}", *raw_ptr);
        }
    }

    unsafe {
        println!(
            "尝试访问悬垂裸指针指向的值: {}",
            *raw_ptr
        );
    }
}
// 运行输出:
// 智能指针管理的值: 55
// 裸指针指向的值: 55
// 尝试访问悬垂裸指针指向的值: 55
```

第二个方案是避免使用裸指针：将`raw_ptr`替换为Rust的引用。这样可以充分利用Rust的借用检查器，在编译阶段就确保所有引用都不会出现悬垂问题，正如1.3节所展示的那样。